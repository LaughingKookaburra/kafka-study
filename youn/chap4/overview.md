# 컨슈머 개념
- 컨슈머는 컨슈머 그룹의 일부로 작동한다.
  - 동일한 컨슈머 그룹의 컨슈머들은 각각 다른 파티션의 레코드들을 전달받는다.
- 한 컨슈머가 여러 파티션을 구독할 수 있지만 여러 컨슈머가 한 파티션을 구독할 수 없다.
- 다른 컨슈머 그룹을 추가하면 해당 그룹은 완전 별개로 해당 토팍을 전달받는다.

### 컨슈머 그룹과 파티션 리밸런스
컨슈머중 하나가 종료되거나 새로운 컨슈머가 추가될 경우 컨슈머별 파티션을 조정하는 경우 
- 조급한 리밸런스
  - 모든 컨슈머다 작업을 멈춘다.
  - 파티션을 각각 다시 할당하고 작업을 재시작한다.
- 협력적 리밸런스
  - 조정 작업이 필요한 컨슈머를 제외하고 나머지 컨슈머는 계속 작업을 한다.
  - 컨슈머들은 그룹코티네이터 브로커에게 하트비트를 전송항 할당된 파티션의 소유권을 유지한다.

### 고정 할당 (정적 그룹 멤버쉽)
기본적으로 컨슈머 그룹의 멤버쉽은 일시적이고 파티션 할당도 마찬가지이다.

단, group.instance.id 설정을 통해 특정 파티션을 특정 컨슈머에 지정할 수 있다. 너무 오랫동안 멈춰있다가 다시 할당되면
밀린 메세지를 처리할 수 있을까에 대한 고민이 필요하다.

# 폴링 루프
```
while (true) {
  Records reocrds = consumer.poll(timeOut);
  for (Record record : records) {
    //do something
  }
}
```
- while (ture) : 의도적으로 종료하거나 서버가 내려가지 않으면 계속해서 컨슈밍을 한다.
- Records records = consumer.poll(timeOut);
  - 컨슈머가 일정시간동안 폴링을 하지 않으면 브로커가 죽은거로 판단한다.
  - timeOut은 버퍼에 데이터가 없을 때 poll이 블록되는 최대 시간이다.
  - poll이 max.poll.interval.ms에 지정된 시간 이상으로 호출되지 않으면 컨슈머는 죽은거로 판단된다.

  
# 컨슈머 설정
- fetch.min.bytes : 레코드를 받아올 때 데이터의 최소량
- fetch.max.wait.ms : 브로커가 컨슈머에게 데이터를 보낼 때 충분한 데이터가 모이게 기다리도록 하는 시간.
  - 데이터가 부족하면 얼마나 기다릴지 결정
  - 잠재적인 지연을 제한하고 싶으면 해당 값을 감소시키면 된다.
- fetch.max.bytes: 컨슈머가 폴링할 때 카프카가 리턴하는 최대 바이트 수
- max.poll.records: poll()을 호출할 때마다 리턴되는 최대 레코드 수
- session.timeout.ms : 컨슈머가 브로커에게 신호를 보내지 않아도 안죽었다고 판단하는 최대 시간
- heartbeat.interval.ms : 하트비트를 보내는 주기 (보통 session.timeout.ms의 3분의1정도로 한다)
- max.poll.interval.ms : 컨슈머가 폴링을 하지 않아도 안죽었다고 판단하는 최대 시간
- request.timeout.ms : 컨슈머가 브로커로부터 응답을 기다리는 최대 시간
- auto.offset.reset : 파티션을 새로 읽기 시작할 때 어떻게 읽을건지
  - earliest : 처음부터
  - latest : 제일 최근
- enable.auto.commit : 컨슈머가 자동으로 오프셋을 커밋할지의 여부
  - auto.commit.interval.ms 를 통해 얼마나 자주 커밋할지 조절이 가능하다.
- partition.assignment.strategy 
  - range : 각 토픽의 파티션들을 연속된 그룹으로 나눠서 할당
  - round robin : 모든 파티션을 순차적으로 파티션에 하나씩 할당
  - sticky : round robin보다 좀 더 균등하게 배분
  - cooperative sticky : 협력적 리밸런스 지원해주는 sticky
- offsets.retention.minutes : 컨슈머가 어디까지 읽었는지 판단하는 토픽의 거장 기간 (일주일이 기본값)

# 오프셋과 커밋
컨슈머가 레코드를 소비하면 __consumer_offset이라는 토픽으로 메세지를 쏴서 자신이 어디까지 처리했는지 브로커에 알려준다.

### 자동 커밋
enable.auto.commit = true로 하면 컨슈머는 5초에 한번 마지막 메세지의 오프셋을 커밋한다. 편리하긴 하나
도중에 크래쉬가 나면 중복된 메세지 처리가 발생할 수 있다.

### 현재 오프셋 커밋
commitSync() 는 마지막 오프셋을 커밋하고 실패하면 예외를 발생시킨다. 만약 모든 레코드를 처리하기전에 호출하면
크래쉬가 발생할 경우 누락 메세지가 생긴다.

### 비동기적 커밋
commitAsync()는 비동기로 처리하기에 처리 성능에 효율적이다. 다만 커밋을 실패해도 재시도를 하지 않기 때문에 
1. 20까지 처리완료
2. 비동기 커밋 -> 브로커에서 못받음
3. 30까지 처리 완료
4. 비동기 커밋 -> 성공
5. 20 커밋
이런 상황이 발생할 수 있다.

### 같이 사용
보통은 문제가 없는 상황에서는 (while문 안에는) commitAsync()를 문제가 생겨 폴루프 밖으로 벗어나는 상황은
commitSync()를 사용하는 방식을 활용한다.

# 리밸런스 리스너 
컨슈머가 종료, 리밸런싱이 되기 전에 마지막으로 처리한 레코드의 오프셋을 커밋해야 한다. 컨슈머 API는 3가지 메서드를 지원해준다
1. onPartitionAssigned : 파티션이 컨슈머에 재할당된 후에 컨슈머가 메세지를 읽기전에 호출. 오프셋 탐색, 메타 정보 적재 등을한다.
2. onPartitioningRevoked : 할당되었던 파티션이 해제될 때 호출. 여기서 오프셋을 커밋해줘야 해당 파티션을 다음 컨슈머가 어디서부터 시작할지 알 수 있다.
3. onPartitionLost : 협력적 리밸런싱이 실행되었을 때 호출된다. 이 메서드가 호출되는 시점에서 파티션들은 이미 다른 컨슈머에 등록되어 있다.



